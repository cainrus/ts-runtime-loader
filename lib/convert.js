const path = require("path");
const mfs = new (require("memory-fs"))();
const fs = require("fs");
const webpack = require("webpack");
const getAssets = require("./utils");
const promisify = require("util").promisify;
const mkdirp = promisify(mfs.mkdirp.bind(mfs));
const writeFile = promisify(mfs.writeFile.bind(mfs));
const readFile = promisify(fs.readFile);

const tsRuntimeSource = require.resolve("ts-runtime/lib/index.js");
const flowRuntimeSource = require.resolve("flow-runtime/dist/flow-runtime.js");
const webpackRuntimeSource = require.resolve("webpack/buildin/global.js");

const compile = ({ rootContext, context, entry }) =>
  new Promise((resolve, reject) => {
    const tsRuntimeTarget = path.normalize(
      `${rootContext}/node_modules/ts-runtime/lib/index.js`
    );
    const flowRuntimeTarget = path.normalize(
      `${rootContext}/node_modules/flow-runtime/index.js`
    );
    const webpackRuntimeTarget = path.normalize(
      `${rootContext}/node_modules/webpack/buildin/global.js`
    );

    Promise.all([
      mkdirp(path.dirname(tsRuntimeTarget)),
      mkdirp(path.dirname(flowRuntimeTarget)),
      mkdirp(path.dirname(webpackRuntimeTarget))
    ])
      .then(() => {
        return Promise.all([
          readFile(tsRuntimeSource, "utf8"),
          readFile(flowRuntimeSource, "utf8"),
          readFile(webpackRuntimeSource, "utf8")
        ]);
      })
      .then(([tsRuntime, flowRuntime, webpackRuntime]) => {
        return Promise.all([
          writeFile(tsRuntimeTarget, tsRuntime),
          writeFile(flowRuntimeTarget, flowRuntime),
          writeFile(webpackRuntimeTarget, webpackRuntime)
        ]);
      })
      .then(() => {
        const compiler = webpack({
          context,
          entry: { app: entry },
          output: {
            filename: "[name].js",
            path: "/build",
            libraryTarget: "commonjs"
          }
        });

        compiler.inputFileSystem = mfs;
        compiler.outputFileSystem = mfs;
        compiler.resolvers.normal.fileSystem = mfs;
        compiler.resolvers.context.fileSystem = mfs;

        compiler.run((err, stats) => {
          if (err) {
            reject(err);
          } else if (stats.hasErrors()) {
            reject(stats.toJson().errors[0]);
          } else {
            const content = mfs.readFileSync("/build/app.js", "utf8");
            resolve(content);
          }
        });
      })
      .catch(reject);
  });

var walkSync = function(dir, filelist) {
  const files = mfs.readdirSync(dir);

  filelist = filelist || [];
  files.forEach(file => {
    if (mfs.statSync(path.join(dir, file)).isDirectory()) {
      filelist = walkSync(path.join(dir, file), filelist);
    } else {
      filelist.push(path.join(dir, file));
    }
  });
  return filelist;
};

module.exports = function(data, callback) {
  // Get normalized assets list.
  const assets = getAssets(data.resourcePath, data.rootContext);
  // Clean generated by ts-runtime data.

  walkSync("/").forEach(path => {
    mfs.unlinkSync(path);
  });

  // Write normalized assets to memory fs.
  assets.forEach(item => {
    mfs.mkdirpSync(path.dirname(item.name));
    mfs.writeFileSync(item.name, item.text);
  });

  const entry = assets[assets.length - 2].name;

  compile({
    fs: mfs,
    rootContext: data.rootContext,
    context: data.context,
    entry
  })
    .then(result => {
      callback(null, result);
    })
    .catch(err => {
      callback(err);
    });
};
